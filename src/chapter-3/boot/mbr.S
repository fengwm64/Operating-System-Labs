;;;
; Author: 
; Date: 2023-05-10 18:43:58
; LastEditTime: 2023-06-11 10:56:27
; FilePath: /OSLab/boot/mbr.S
; Description: 主引导程序 MBR-V4.0 loader突破512字节（一个扇区）
; Copyright (c) 2023 by GZHU-FWM, All Rights Reserved. 
;;;

%include "boot.inc"

SECTION MBR vstart=0x7c00     ; 起始地址编译为0x7c00

; 初始化寄存器
; ---------------------------------------------------------------------------------   
   ; 此时cs = 0 (BIOS是通过jmp 0:0x7c00 跳转到MBR的)
   ; 使用cs初始化ax，再使用ax去初始化其他寄存器
   ; Q:为什么用寄存器给寄存器赋值？
   ; A:没有从立即数到段寄存器的电路实现
   mov ax,cs
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00  ; 初始化栈指针
                  ; mbr也是程序，是程序就要用到栈
   mov ax,0xb800  ; 使用ax来初始化显存地址（文本模式）
   mov gs,ax
; ---------------------------------------------------------------------------------   

; 清屏
; ---------------------------------------------------------------------------------   
; 上卷窗口
; 输入：
; ah = 功能号0x06    al = 上卷的行数(如果为0,表示全部)


   mov ax, 0600h     ; AH 功能号=0x06 AL=上卷的行数(如果为0,表示全部)
   mov bx, 0700h     ; BX 定义字体配色:白底黑字

   ; VGA文本模式 列:80,行：25
   mov cx, 0         ; (CL,CH)=左上角坐标(X,Y): (0, 0)
   mov dx, 184fh     ; (DL,DH)=右上角坐标(X,Y): (0x18[24],0x4f[79])
   
   ; 调用10号bios中断
   int 0x10          
; ---------------------------------------------------------------------------------   

; 使用显存输出字符串:MBR-fengWeiMing
; ---------------------------------------------------------------------------------
   mov ah, 0x2A         ; 定义显示模式
   mov bx, 0x00         ; 目标内存地址的偏移量
   mov cx, msg_len      ; 打印字符串长度
   mov esi, msg         ; 将要打印的字符串地址保存到esi寄存器中
   print_msg:
      lodsb             ; 从esi指向的字符串中读取一个字节到al寄存器中，并将esi自加1
      mov [gs:bx], al   ; 向目标位置写入字符
      inc bx            ; bx++
      mov [gs:bx], ah   ; 指定显示模式为ah
      inc bx            ; bx++
      dec cx            ; cx--，cx为循环次数
      cmp cx, 0         ; 判断cx是否>0
      jne print_msg    ; 循环处理，直到所有字符串都打印完毕 
; ---------------------------------------------------------------------------------   

; 读取硬盘
; ---------------------------------------------------------------------------------   
;为读取硬盘例程（函数）传输参数
   ; 所用寄存器：eax bx cx 
   mov eax, LOADER_START_SECTOR  ; 传入起始扇区lba地址
   mov bx, LOADER_BASE_ADDR      ; loader加载到内存的地址
   mov cx, 4                     ; 将要读入的扇区数4

; 调用函数
   call rd_disk_m_16             ; 调用读取硬盘的子函数
; ---------------------------------------------------------------------------------   

; 跳转到loader
; ---------------------------------------------------------------------------------   
   jmp  LOADER_BASE_ADDR
; ---------------------------------------------------------------------------------   


; 读取硬盘函数
; --------------------------------------------------------------------------------- 
; 传入：
; eax 起始扇区lba地址
; bx loader加载到内存的地址
; cx 将要读入的扇区数

rd_disk_m_16:
; 0. 备份eax cx
; ---------------------------------------------------------
   mov esi, eax   ; al在out指令中会使用到
   mov di, cx     ; cx在读取数据时用到
; ---------------------------------------------------------
; 1. 选择通道；设置读取扇区数
   mov dx, 0x1f2  ; 设置Primary通道
   mov al, cl     ; al=cl（读入的扇区数）
   out dx, al     ; 将al的数据（读入的扇区数）写入dx指向的地址
   mov eax, esi   ; 恢复ax
; ---------------------------------------------------------
; 2. 起始地址写入LBA寄存器
   ; 7-0 位地址写入端口 0x1f3
   mov dx, 0x1f3  ; 设置Primary通道
   out dx, al     ; 写入eax低8位
   ; 15-8位地址写入端口 0x1f4
   mov cl, 8      ; 设置右移位数8
   shr eax, cl    ; 将eax内地址右移8位
   mov dx, 0x1f4  ; 设置Primary通道
   out dx, al     ; 写入eax低8位(因为右移，此时低8相当于原8-15位)
   ; 23-16位地址写入端口 0x1f5
   shr eax, cl    ; 将eax内地址右移8位
   mov dx, 0x1f5  ; 设置Primary通道
   out dx, al     ; 写入eax低8位(因为右移，此时低8相当于原16-23位) 
   ; 27-24位地址写入端口 0x1f6 && 设置mba模式
   shr eax, cl    ; 将eax内地址右移8位
   and al, 0x0f   ; 保留al的低4位（此时地址就剩4位没存了）
   or al, 0xe0    ; 设置al高4位为1110（lba模式）
   mov dx, 0x1f6  ; 设置Primary通道
   out dx, al     ; 写入eax低8位(4位地址+0[DEV]+1+1[MOD]+1)
; ---------------------------------------------------------
; 3. 写入读命令
   mov dx, 0x1f7  ; 设置Primary通道
   mov al, 0x20   ; 0x20读取
   out dx, al     ; 向command寄存器写入命令
; ---------------------------------------------------------
; 4. 读取staus寄存器获取硬盘状态
; 没准备好时
.not_ready:
   nop            ; 相当于睡眠一小会，避免太频繁查询
   in al, dx      ; 读取dx指向的寄存器status的值

   ; 第7位：1忙   第3位：1就绪
   and al, 0x88   ; 0x88=1000_1000
   cmp al, 0x08   ; 0x08=0000_1000 
                  ; ZF=1：就绪
                  ; ZF=0：忙，跳转.not_ready
   jnz .not_ready ; if ZF=0 跳转.not_ready
; ---------------------------------------------------------
; 5. 读取硬盘
   mov ax, di        ; di(需要读入的扇区数)放进ax
   mov dx, 256       ; 一个扇区512字节，每次in读入2字节，共需要读取di*512/2次
   mul dx            ; 乘法 
                     ; 被乘数：ax/al
                     ; 乘数：dx
                     ; 结果：ax[8位乘法] / ax+dx[16位乘法]
   mov cx, ax        ; 将结果(循环次数)放入cx
   mov dx, 0x1f0     ; 设置Primary通道
.go_on_read:
   in ax, dx         ; 从dx寄存器所指向的端口地址中读取2字节到ax寄存器中
   mov [bx], ax      ; ax的数据放入bx所指向的地址中
   add bx, 2         ; 地址向后偏移2个字节
   loop .go_on_read  ; 根据cx寄存器的值进行循环，每次循环cx--直到0
   ret               ; return 到 call 下一行
; ---------------------------------------------------------------------------------   


; 程序使用的变量
; ---------------------------------------------------------------------------------
   msg db 'MBR-fengWeiMing'      ; 定义字符串，显示MBR-fengWeiMing
   msg_len equ $ - msg           ; 计算msg的长度，当前内存位置-message起始位置 
   times 510-($-$$) db 0         ; 0,用于填充，保证mbr大小510[512=510+1(0x55)+1(0xaa)]字节
   db 0x55,0xaa                  ; 魔数，mbr最后两个字节必须为0x55,0xaa，用于识别
; ---------------------------------------------------------------------------------   
